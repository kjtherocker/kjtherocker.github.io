<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <title>Kyle Johnson - Portfolio</title>
  <link href="https://fonts.googleapis.com/css?family=Merriweather" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Montserrat" rel="stylesheet">
  <link href="css/main.css" rel="stylesheet">
  <link href="css/gallery.css" rel="stylesheet">
  <link href="css/gallery.theme.css" rel="stylesheet">
  <link href="css/summary.css" rel="stylesheet">
</head>
<body>
  <!-- Header -->
  <div class="header">

    <!-- Buttons -->
    <div class="header-buttons">
		<a href="index.html">Home</a>
        <a href="portfolio.html">C# Portfolio</a>
		<a href="PortfolioC++.html"  class="active">C++ Portfolio</a>
		<a href="WorkEX.html">Work Experience</a>
		<a href="Resume.html">Resume</a>
    </div>

    <!-- Logo -->
    <div class="logo">
      <strong><a href="index.html">Kyle Johnson</a></strong>
    </div>
  </div>
  
  


  <div class="main">
    <br/>

    <div class="content">
	      <p style="color:Black;font-size:75px;"> <b>Unreal Tower Defence</b>		</p>
		  <!-- TCTD -->
		 
	  <a href="https://drive.google.com/drive/folders/1O6BKE4tHSP9RzG-d5ZYVq2tUFe7Srt9h?usp=sharing" target="_blank"><div class="tag-link">Click this for demo</div></a>

      
      <br/>

	  <div class="tag tag-teal">Only Programmer</div>
      <div class="tag tag-yellow">Unreal</div>
	  <div class="tag tag-teal">C++</div>
      <div class="tag tag-blue">Ai</div>


     <p>
		<b>Unreal Tower Defence</b> is a project I made to try and get used to the Unreal Game Engine while reusing assets from
		Twilights Call's to quickly speed up development time.
		
	</p>
	
	<p>
			 
	   
      <p>
       <b>Unreal Tower Defence</b> is a very basic Tower Defence game. You can place towers and when an enemy
	   enters the Turrets range it fires a projectile to attack the enemy. When an enemy has incurred too much 
	   damage it will die and give the player more money to buy more turrets.
	   </p>
	   
	   	  
	  <div id="demobox">
	<body>
    <section>
      <article>
        <details>
		
			 
	     <!-- GamePlay Programmer-->
          <summary>Code: Turret Lock Calculation</summary>
		   
     </p>
 	  <p>
		Each Turret has an area around itself and when an enemy enters or leaves its collision radius it triggers the
		turret to recalulate. The calculation is handled inside the enemy class. Enemy keeps track of how close it is 
		to the current waypoint based on distance and how much distance is there between every other waypoint.
		</p>
		 <p>
		Example: 
		</p>
		<p>
		DistanceToCurrentWaypoint would be 780 but the distance to each waypoint left could be 2345.
		</p>
		
		<p>
		CurrentDistanceRemaining  = DistanceToCurrentWaypoint + DistanceInAllRemainingWaypoints
		</p>
	 

	 
	 
	 	 <p>
		<b>Code Example</b>
	 
	 </p>
	 
	 <textarea id="w3review" name="w3review" rows="40" cols="136">


// returns the full distance from start to end
float AEnemy_Base::CalculateDistanceFromRemainingToEnd()
{
	
	TArray<FVector> TempWaypoints = Waypoints;
	float TempDistance = 0;
	
// if there is less then two checkpoints remaining then we will return 0
	if(!TempWaypoints.IsValidIndex(0) ||!TempWaypoints.IsValidIndex(1) )
	{
		return 0;
	}


//Loop through each of the waypoints but remove one since we are incrementing above the List 
	for(int i = 0; i < TempWaypoints.Num() - 1;i++)
	{
		if(TempWaypoints.IsValidIndex(i + 1))
		{
//Calculating the Distance Between the current waypoint and the next 
			TempDistance +=  FVector::Dist(TempWaypoints[i], TempWaypoints[i + 1]);
		}
	}
	
	return TempDistance;
}

----------------------------------------------------------------------------------------------------


//Used when we have reached the current checkpoint and we are asking for the next one 
void AEnemy_Base::GoToNextWaypoint()
{
//If there are no waypoints left the enemy has gotten to the goal


	if(Waypoints.Num() == 0)
	{
		EnemyGotToGoal();
		return;
	}


//Calculating the distance between all the waypoints remaining
	DistanceInAllRemainingWaypoints = CalculateDistanceFromRemainingToEnd();
	
//Attaching waypoint
	CurrentWaypoint = Waypoints[0];
	Waypoints.RemoveAt(0);

}


-----------------------------------------------------------------------------------------------


// Called in update
public void AEnemy_Base::MoveToWaypoint(float aDeltaTime)
{
	DistanceToCurrentWaypoint = FVector::Dist(GetActorLocation(), GoToWaypoint);
	CurrentDistanceRemaining = DistanceToCurrentWaypoint + DistanceInAllRemainingWaypoints;
}


-----------------------------------------------------------------------------------------------

// Inside the Turret, This is called every time someone enters or leaves the collision radius

void ATurret::CalculateClosestEnemy()
{
//If there is no enemy in range then exit the function
	if(!EnemyInRange.IsValidIndex(0))
	{
		return;
	}
	
	
//Setting the Default starting enemy for comparison

	AEnemy_Base* EnemyTemp = Cast<AEnemy_Base>(EnemyInRange[0]);
	
//If there is more then one enemy do the calculations
	
	if(EnemyInRange.Num() > 1)
	{
		for (int i = 0; i < EnemyInRange.Num(); i++)
		{
			
		
			AEnemy_Base* IterativeEnemy = Cast<AEnemy_Base>(EnemyInRange[i]);

//If the Waypoints are not initialize then continue the loop
			if(IterativeEnemy->WaypointsAreSet == false)
			{
				continue;
			}


//Getting the absolute value of the distances
			float EnemyA = abs(IterativeEnemy->DistanceLeftInLevel);
			float EnemyB = abs(EnemyTemp->DistanceLeftInLevel);


//Safety Check that if both values are 0 then something wrong is happening
			if(EnemyA == 0 || EnemyB == 0 )
			{
				continue;
			}
			
			
//Direct comparison between the two values the shortest distance will be swapped
			if(EnemyA < EnemyB )
			{
				EnemyTemp = IterativeEnemy;
			}
		}
	}
	
	
// The enemy that is furthest ahead will be selected.
	EnemyToAttack = EnemyTemp;
	
//Adding the enemy to a delegate that gets called when the enemy is killed
	EnemyToAttack->EnemyDeathEvent.AddDynamic(this, &ATurret::EnemyWasKilled);
}





	</textarea>
	 

	  
        </details>

      </article>
      </div>


</section>
</body>




      
    <iframe width="1000" height="315" src="https://www.youtube.com/embed/0vU-RKz3A7w" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>


<!--FURI LITE -->

 <p style="color:Black;font-size:75px;"> <b>FURI LITE</b>		</p>


	  <a href="https://github.com/kjtherocker/Furi-Lite" target="_blank"><div class="tag-link">Click this for GitRepo</div></a>
	  
	    <br/>
	  <div class="tag tag-teal">Only Programmer</div>
      <div class="tag tag-teal">Box 2D</div>
      <div class="tag tag-blue">C++</div>
      <div class="tag tag-yellow">Open GL</div>
	  <div class="tag tag-yellow">3D</div>

      <p>
        Furi Lite is a boss rush game similar to the likes of Maiden & Spell aswell as Furi;  created
		using Box 2D and Open Gl.
	 </p>
	  <div id="demobox">
	<body>
    <section>
      <article>
        <details>
		
			 
	     <!-- UI Manager-->
          <summary>Shader Cube Map Reflection</summary>
		   
     </p>
 	  <p>
		A basic Cube Map Reflection Shader using Open GL.
		
	 </p>
	 

	 
	 
	 	 <p>
		<b>Code Example</b>
	 
	 </p>
	 
	 <textarea id="w3review" name="w3review" rows="40" cols="136">


// Cube Map Reflection Fragment Shader

uniform samplerCube u_TextureCube;

uniform vec3 u_CameraPosition;

varying vec3 v_SurfaceToWorldPosition;
varying vec3 v_Normal;
varying vec2 v_UV;
varying vec3 v_Cubeuv;

void main()
{

	vec3 NormalizedNormal = normalize(v_Normal);

	vec3 CubeColor = textureCube( u_TextureCube, v_Cubeuv );

	vec3 Surfacepos = v_SurfaceToWorldPosition; 

	vec3 Direction2Camera = Surfacepos - u_CameraPosition;

	vec3 NormalizedDirection2Camera = normalize(Direction2Camera);

	vec3 Reflection = reflect(NormalizedDirection2Camera, NormalizedNormal);

	vec4 ReflectedColor = texture(u_TextureCube, Reflection);

	gl_FragColor = ReflectedColor;
	
}

----------------------------------------------------------------------------------------

// Cube Map Reflection Vertex Shader

attribute vec4 a_Position;
attribute vec2 a_UV;
attribute vec4 a_Color;
attribute vec3 a_Normal;

uniform mat4 u_WorldMatrix;
uniform mat4 u_ViewMatrix;
uniform mat4 u_ProjMatrix;
uniform vec3 u_CameraPosition;

varying vec3 v_SurfaceToWorldPosition;
varying vec3 v_Normal;
varying vec2 v_UV;
varying vec3 v_Cubeuv;

void main()
{
   vec4 objectpos = a_Position;
    vec4 worldpos = u_WorldMatrix * objectpos;
    vec4 viewpos = u_ViewMatrix * worldpos;
    vec4 clippos = u_ProjMatrix * viewpos;


	v_UV = a_UV;
	v_Cubeuv = objectpos.xyz;
	v_Normal = a_Normal;
	v_SurfaceToWorldPosition = worldpos.xyz;



    gl_Position = clippos;

}

	</textarea>
	 


        </details>

      </article>
      </div>


</section>
</body>

	  <div id="demobox">
	<body>
    <section>
      <article>
        <details>
		
			 
	     <!-- UI Manager-->
          <summary>Boss AI</summary>
		   
     </p>
 	  <p>
		Furi Lite was setup to have two different bosses that had different attakcks they could use to fight the player
		Each action was setup as its own class and when executed it hijacks the positions and executes the action.
		
	 </p>
	 

	 
	 
	 	 <p>
		<b>Code Example</b>
	 
	 </p>
	 
	 <textarea id="w3review" name="w3review" rows="40" cols="136">

#include "GamePCH.h"




void ProjectileObject::Update(float deltatime)
{   
    m_ProjectileLifetme -= deltatime;

	if (m_Position.z > 0 || m_Position.z < 0)
	{
		m_Position.z = 0;
	}

    if (m_ProjectileLifetme <= 0)
    {
		if (m_pPool)
		{
			Destroy();
		}       
    }
// Shoots in astraight line
	if (m_ProjectileType == Line)
	{
		if (m_IsShot == false)
		{
			
            SetMaterial(m_pMaterial);
			float m_Speed = PROJECTILESPEED;
	        m_Playerpos = m_pPlayerObject->GetPosition();
			m_DirectionVector = b2Vec2(m_Playerpos.x - m_Position.x, m_Playerpos.y - m_Position.y);
			m_DirectionVector.Normalize();
			m_IsShot = true;
		}
		m_Position += (vec3(m_DirectionVector.x, m_DirectionVector.y, m_Position.z) * m_Speed * deltatime);
		this->GetPhysicsBody()->ApplyLinearImpulseToCenter(b2Vec2(m_DirectionVector.x * m_Speed * deltatime, m_DirectionVector.y * m_Speed * deltatime), true);
		m_Position.x = this->GetPhysicsBody()->GetPosition().x;
		m_Position.y = this->GetPhysicsBody()->GetPosition().y;
	}
	
	
// Moves slightly towards the player
	if (m_ProjectileType == Homing)
	{		
		m_TextureTimer -= deltatime;

		if (m_IsShot == false)
		{
			SetMaterial(m_pGame->GetResourceManager()->GetMaterial("TextureHomingProjectile1"));
			float m_Speed = HOMINGPROJECTILESPEED;
			m_IsShot = true;
		}

		if (m_TextureTimer < 0.4f && m_Phase == 0)
		{
			m_Phase++;
			SetMaterial(m_pGame->GetResourceManager()->GetMaterial("TextureHomingProjectile2"));
		}
		if (m_TextureTimer < 0.3f && m_Phase == 1)
		{
			m_Phase++;
			SetMaterial(m_pGame->GetResourceManager()->GetMaterial("TextureHomingProjectile3"));
		}
		if (m_TextureTimer < 0.2f && m_Phase == 2)
		{
			m_Phase++;
			SetMaterial(m_pGame->GetResourceManager()->GetMaterial("TextureHomingProjectile4"));
		}
		if (m_TextureTimer < 0.1f && m_Phase == 3)
		{
			SetMaterial(m_pGame->GetResourceManager()->GetMaterial("TextureHomingProjectile5"));
		}
		if (m_TextureTimer < 0)
		{
			SetMaterial(m_pGame->GetResourceManager()->GetMaterial("TextureHomingProjectile1"));
			m_TextureTimer = 0.5;
			m_Phase = 0;
		}

			m_Playerpos = m_pPlayerObject->GetPosition();
			m_DirectionVector = b2Vec2(m_Playerpos.x - m_Position.x, m_Playerpos.y - m_Position.y);
			m_DirectionVector.Normalize();

//Adding a physics pulse towards the target 
			m_Position += (vec3(m_DirectionVector.x, m_DirectionVector.y, m_Position.z) * m_Speed * deltatime);
			this->GetPhysicsBody()->ApplyLinearImpulseToCenter(b2Vec2(m_DirectionVector.x * m_Speed * deltatime, m_DirectionVector.y * m_Speed * deltatime), true);
			m_Position.x = this->GetPhysicsBody()->GetPosition().x;
			m_Position.y = this->GetPhysicsBody()->GetPosition().y;		
	}

}

void ProjectileObject::Reset()
{
    Destroy();
}


void ProjectileObject::Destroy()
{
//When Destoryed it removes itself
    RemoveFromSceneEvent* pEvent = new RemoveFromSceneEvent(this);
    m_pScene->GetGame()->m_EventQueue.push(pEvent);
}

void ProjectileObject::RemoveFromScene()
{
    GameObject::RemoveFromScene();

    ResetTimers();
	
//Turn off Physics Bodys
    this->GetPhysicsBody()->SetActive(false);
    this->GetPhysicsBody()->SetAwake(false);


    if (m_pPool)
    {
        m_pPool->ReturnObject(this);
    }
}

void ProjectileObject::ResetTimers()
{
    m_IsShot = false;
    m_ProjectileLifetme = PROJECTILELIFETIME;
    m_Speed = PROJECTILESPEED;
}



	</textarea>
	 


        </details>

      </article>
      </div>


</section>
</body>


      <div class="gallery items-3">
        <div id="item-1" class="control-operator"></div>
        <div id="item-2" class="control-operator"></div>
        <div id="item-3" class="control-operator"></div>
    
         <figure class="item">
          <img src="Images/MainMenu.png">
        </figure>
    
        <figure class="item">
          <img src="Images/Title_Menu.png">
        </figure>
    
    
        <div class="controls">
          <a href="#item-1" class="control-button">•</a>
          <a href="#item-2" class="control-button">•</a>
        </div>
      </div>
   
   
   
   
 <p style="color:Black;font-size:75px;"> <b>Tank To Tank</b>		</p>


	  <a href="https://github.com/kjtherocker/Tank-Game" target="_blank"><div class="tag-link">Click this for GitRepo</div></a>
	  
	    <br/>
	  <div class="tag tag-teal">Only Programmer</div>
      <div class="tag tag-blue">C++</div>

      <p>
        Tank To Tank is a small prototype I made in 2017 to practice C++ after my first year in the Game Development program.
		
		Tank To Tank is a 2 player game based around shooting barrels and in each barrel there is a walky talkie and the first 
		tank to grab one wins
		

		For this prototype, I used a framework created by one of my college professors
	 </p>

	 

	 
     <div class="gallery items-3">
        <div id="item-7" class="control-operator"></div>
        <div id="item-8" class="control-operator"></div>
        <div id="item-9" class="control-operator"></div>
    
        <figure class="item">
          <img src="Images/TankToTank1.png">
        </figure>
    
        <figure class="item">
          <img src="Images/TankToTank2.png">
        </figure>
    
        <figure class="item">
          <img src="Images/TankToTank3.png">
        </figure>
    
        <div class="controls">
          <a href="#item-7" class="control-button">•</a>
          <a href="#item-8" class="control-button">•</a>
          <a href="#item-9" class="control-button">•</a>
        </div>
      </div>

     

</section>
</body>




    </div>
  </div>
</body>
</html>
